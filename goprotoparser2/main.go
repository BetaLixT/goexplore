package main

import (
	// "encoding/json"
	// "flag"
	// "fmt"
	// "os"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/types/pluginpb"
)


func GenerateFile(gen *protogen.Plugin, file *protogen.File) (*protogen.GeneratedFile, error) {
	isGenerated := false
	for _, srv := range file.Services {
		for _, method := range srv.Methods {
			if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
				continue
			}
			isGenerated = true
		}
	}

	if !isGenerated {
		return nil, nil
	}

	filename := file.GeneratedFilenamePrefix + ".http.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)

	g.P("// Code generated by protoc-gen-gohttp. DO NOT EDIT.")
	g.P("// source: ", file.Desc.Path())
	g.P()
	g.P("package ", file.GoPackageName)

	for _, srv := range file.Services {
		if err := genService(g, srv); err != nil {
			return nil, err
		}
	}

	return g, nil
}

func genService(g *protogen.GeneratedFile, srv *protogen.Service) error {
	// genServiceInterface(g, srv)
	// genStruct(g, srv)
	// genConstructor(g, srv)

	for _, method := range srv.Methods {
		if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
			continue
		}

		// genMethod(g, method)
		// genMethodWithName(g, method)
		// if err := genMethodHTTPRule(g, method); err != nil {
		// 	return err
		// }
	}

	return nil
}

func main() {
	major := int32(3)
	minor := int32(19)
	patch := int32(4)

	req := pluginpb.CodeGeneratorRequest{
		FileToGenerate: []string{"contracts.proto"},
		Parameter: nil,
		ProtoFile: nil,
		CompilerVersion: &pluginpb.Version{
			Major: &major,
			Minor: &minor,
			Patch: &patch,
		},
	}
	optn := protogen.Options{}
	_, err := optn.New(&req)
	if err != nil {
		panic(err)
	}
	// GenerateFile()
}
